<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kubernetes on Ibiza</title>
    <link>http://kimmj.github.io/tags/kubernetes/</link>
    <description>Recent content in kubernetes on Ibiza</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Dec 2020 02:02:49 +0900</lastBuildDate>
    
	<atom:link href="http://kimmj.github.io/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Overview</title>
      <link>http://kimmj.github.io/kubernetes/installation/overview/</link>
      <pubDate>Tue, 14 Jan 2020 01:42:53 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/installation/overview/</guid>
      <description>저의 vm으로 구성한 클러스터를 설명드리고자 합니다.
 Cloud Provider: Kubernetes on-prem (4 VMs)  1 for master (4GB Mem, 2 CPU) 3 for worker (each 8GM Mem, 4 CPU)   Kubernetes 1.17.0 Storage Class: Ceph OS: Ubuntu 18.04.2 Server Internal Network: VirtualBox Host-Only Ethernet Adapter (192.168.x.0/24) External Network: Bridge to adapter (192.168.y.0/24)  한번에 쳐야하는 명령어가 많기 때문에, tmux를 사용해서 여러개의 pane을 생성하고 각각에 대해 ssh로 접속하였습니다.</description>
    </item>
    
    <item>
      <title>Controllers Overview</title>
      <link>http://kimmj.github.io/kubernetes/concepts/controllers-overview/</link>
      <pubDate>Thu, 30 Jan 2020 18:26:04 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/concepts/controllers-overview/</guid>
      <description>Contents 이 포스트에서는 Kubernetes의 Controller들에 대해서 알아보도록 하겠습니다. 가장 작은 단위인 Container부터, 상위 개념인 Deployment, StatefulSet까지 다루어 보도록 하겠습니다.
 Containers Pods ReplicaSets Deployments StatefulSets  Monolithic vs. Microservice 우선 Monolithic과 Microservice에 대해서 짚고 넘어가도록 하겠습니다.
Monolithic의 개념은 하나의 큰 어플리케이션을 말합니다. 여러 사람이 개발을 하고 나서 하나의 큰 패키지로 빌드하고 이를 배포하죠. 간단한 서비스라면 문제가 발생하지는 않겠지만, 점점 코드의 수가 늘어나고 거대해질 수록 문제점이 생깁니다. 예를 들면 빌드시간이 오래걸린다던지, scale-out을 하기 힘들다던지 하는 문제가 있겠네요.</description>
    </item>
    
    <item>
      <title>Kubernetes에서의 cpu requests, cpu limits는 어떻게 적용될까</title>
      <link>http://kimmj.github.io/kubernetes/kubernetes-cpu-request-limit/</link>
      <pubDate>Tue, 22 Dec 2020 02:02:49 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/kubernetes-cpu-request-limit/</guid>
      <description>Kubernetes 에서는 컨테이너 단위로 resource를 할당할 수 있다. 여기에는 memory, cpu, ephemeral-storage, hugepages 등이 포함된다. 이 중에서 cpu 의 requests, limits 가 어떤 방식으로 적용이 되는지에 대해 알아볼 것이다.
Linux Kernel 먼저 기본적으로 Kubernetes는 Linux Kernel의 cgroup을 사용하여 리소스 할당을 한다. cgroup은 control groups 의 의미를 가지며 프로세서들의 자원(cpu, memory 등)을 제한하는 기술이다.
CPU Share cpu.shares는 CPU를 다른 group에 비해 상대적으로 얼마나 사용할 수 있는지를 나타내는 값이다. 예를 들어 하나의 CPU를 가지고 있고, 두개의 group이 있다고 해보자.</description>
    </item>
    
    <item>
      <title>[번역] 쿠버네티스에서의 Port, TargetPort, NodePort</title>
      <link>http://kimmj.github.io/kubernetes/port-targetport-nodeport-in-kubernetes/</link>
      <pubDate>Sun, 15 Mar 2020 23:13:37 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/port-targetport-nodeport-in-kubernetes/</guid>
      <description>원문: https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-ports-targetport-nodeport-service.html
쿠버네티스의 port declaration 필드에는 여러가지가 있다. 각 type에 대해 빠르게 살펴보고 YAML에서 각각 어떤 의미를 가지고 있는지 알아보도록 하자.
Pod ports list pod.spec.containers[].ports로 정의된 이 배열은 container가 노출하고 있는 포트의 리스트를 나타낸다. 이 리스트를 꼭 작성해야할 필요는 없다. 리스트가 비어있다고 하더라도 container가 포트를 listening하고 있는 한 여전히 네트워크 접속이 가능하다. 이는 단순히 쿠버네티스에게 추가적인 정보를 줄 뿐이다.
 List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational.</description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://kimmj.github.io/kubernetes/concepts/services/</link>
      <pubDate>Sun, 15 Mar 2020 19:28:06 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/concepts/services/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Stern을 이용하여 여러 pod의 log를 한번에 확인하기</title>
      <link>http://kimmj.github.io/kubernetes/stern/</link>
      <pubDate>Mon, 24 Feb 2020 23:28:01 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/stern/</guid>
      <description>Kubernetes에서의 trouble shooting kubernetes 환경에서 어떤 문제가 발생하면 다음과 같은 flow로 확인을 해보면 됩니다.
 kubectl get pods -o yaml로 yaml을 확인하기 kubectl describe pods로 pod에 대한 설명 확인하기 kubectl describe deployments(statefulset, daemonset)으로 확인하기 kubectl logs로 로그 확인하기  보통 kubernetes 리소스의 부족과 같은 kubernetes단의 문제는 1~3을 확인하면 전부 문제점을 찾을 수 있습니다. 그러나 어플리케이션의 직접적인 원인을 알아보기 위해서는 log를 확인해야 합니다.
하지만 kubectl의 logs에는 한가지 한계점이 있는데, 바로 단일 container에 대해서만 log 확인이 가능하다는 점입니다.</description>
    </item>
    
    <item>
      <title>Pods</title>
      <link>http://kimmj.github.io/kubernetes/concepts/pods/</link>
      <pubDate>Mon, 03 Feb 2020 14:03:50 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/concepts/pods/</guid>
      <description>Pod Overview Pod의 이해 Pod는 Kubernetes에서 가장 작은 배포 오브젝트이며 쿠버네티스에서 관리하는 최소 관리 단위입니다. Pod는 cluster 안에서 실행중인 어떤 프로세스를 의미합니다. application container, 스토리지 리소스, 유일한 network ip, container가 어떻게 실행할지를 캡슐화한 것입니다.
각각의 Pod는 주어진 application에서 단일 인스턴스를 수행합니다. 즉, 한가지 역할을 맡고 있다고 생각하시면 됩니다.. 따라서 application을 수직확장하고 싶다면 각 인스턴스에 대해 여러 Pod를 생성하면 된다. 그러면 동일한 역할을 하는 Pod가 늘어나니, 병렬적으로 처리가 가능할 것입니다.
Pod는 서비스 중에서 서로 연관성이 높은 프로세스를 지원하기 위해 디자인되었습니다.</description>
    </item>
    
  </channel>
</rss>